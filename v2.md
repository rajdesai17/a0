# Goal 2: Documentation Intelligence - Step-by-Step Implementation Guide

## üéØ **Goal 2 Requirements (Simplified)**
1. **Browse & Summarize**: Read API docs from URLs and extract key information
2. **Component Generation**: Create typed React components from documentation
3. **Integration Instructions**: Provide step-by-step implementation guides
4. **Multi-API Support**: Handle multiple documentation sources (e.g., billing + payments)

## üìã **Step-by-Step Implementation Plan**

### **Step 1: Add URL Detection to Chat Input**

**What to build:** Detect URLs in user messages and show preview

**Files to modify:**
- `components/chat/ChatInput.tsx` - Add URL detection
- `components/chat/URLPreview.tsx` - New component for URL preview

**Implementation approach:**
```typescript
// Add to ChatInput component
const detectUrls = (text: string) => {
  const urlRegex = /(https?:\/\/[^\s]+)/g;
  return text.match(urlRegex) || [];
};

// Show detected URLs in real-time
{detectedUrls.length > 0 && <URLPreview urls={detectedUrls} />}
```

**Reference docs:**
- URL regex patterns: MDN Web Docs - Regular Expressions
- React state management: React official docs - useState

### **Step 2: Set Up Firecrawl Integration**

**What to build:** API route for scraping documentation

**Files to create:**
- `app/api/scrape/route.ts` - Scraping API endpoint
- `lib/scraping.ts` - Firecrawl wrapper functions

**Installation:**
```bash
npm install @mendable/firecrawl-js
```

**Environment variables:**
```bash
FIRECRAWL_API_KEY=your_firecrawl_api_key
```

**Implementation approach:**
```typescript
// Basic Firecrawl setup
import FirecrawlApp from '@mendable/firecrawl-js';

const firecrawl = new FirecrawlApp({ 
  apiKey: process.env.FIRECRAWL_API_KEY 
});

// Scrape single page for documentation
const result = await firecrawl.scrapeUrl(url, {
  formats: ['markdown'],
  onlyMainContent: true
});
```

**Reference docs:**
- Firecrawl documentation: https://docs.firecrawl.dev/
- Next.js API routes: https://nextjs.org/docs/app/building-your-application/routing/route-handlers

### **Step 3: Add Puppeteer Fallback (Optional)**

**What to build:** Fallback scraper for sites that block Firecrawl

**Files to modify:**
- `lib/scraping.ts` - Add Puppeteer fallback logic

**Installation:**
```bash
npm install puppeteer
npm install --save-dev @types/puppeteer
```

**Implementation approach:**
```typescript
// Puppeteer fallback for protected sites
import puppeteer from 'puppeteer';

const browser = await puppeteer.launch({
  headless: true,
  args: ['--no-sandbox']
});

// Extract main content and convert to markdown
const content = await page.evaluate(() => {
  // Remove scripts, styles, nav, footer
  // Extract main documentation content
  return document.querySelector('main, .documentation, #docs')?.textContent;
});
```

**Reference docs:**
- Puppeteer documentation: https://pptr.dev/
- Vercel Puppeteer deployment: https://vercel.com/guides/puppeteer-browserless

**Note:** For Vercel deployment, consider using Browserless.io service instead of local Puppeteer.

### **Step 4: Create Documentation Analysis Tool**

**What to build:** AI tool that analyzes scraped documentation

**Files to create:**
- `lib/tools/browseTool.ts` - AI tool for documentation browsing
- `lib/analysis.ts` - Documentation analysis utilities

**Implementation approach:**
```typescript
// AI tool using AI SDK v5
import { tool } from 'ai';

export const browseTool = tool({
  description: 'Browse and analyze API documentation',
  parameters: z.object({
    urls: z.array(z.string()),
    focus: z.string().optional()
  }),
  execute: async ({ urls, focus }) => {
    const results = [];
    
    for (const url of urls) {
      // 1. Scrape documentation
      const scrapedContent = await scrapeUrl(url);
      
      // 2. Analyze with Gemini
      const analysis = await analyzeDocumentation(scrapedContent, focus);
      
      results.push({ url, content: scrapedContent, analysis });
    }
    
    return { documentationResults: results };
  }
});
```

**Reference docs:**
- AI SDK tools documentation: https://sdk.vercel.ai/docs/ai-sdk-core/tools-and-tool-calling
- Google Gemini AI: https://ai.google.dev/docs

### **Step 5: Enhance Component Generation Tool**

**What to build:** Upgrade existing generation to use documentation context

**Files to modify:**
- `lib/tools/generateTool.ts` - Add documentation context
- `app/api/chat/route.ts` - Include both tools

**Implementation approach:**
```typescript
export const generateTool = tool({
  description: 'Generate React components from API documentation',
  parameters: z.object({
    componentName: z.string(),
    documentationContext: z.string(), // New parameter
    requirements: z.string(),
    apiEndpoints: z.array(z.any()).optional() // New parameter
  }),
  execute: async ({ componentName, documentationContext, requirements, apiEndpoints }) => {
    // Enhanced generation prompt with API context
    const enhancedPrompt = `
      Generate ${componentName} component using this API documentation:
      
      API DOCUMENTATION:
      ${documentationContext}
      
      KEY ENDPOINTS:
      ${JSON.stringify(apiEndpoints, null, 2)}
      
      REQUIREMENTS: ${requirements}
      
      Include:
      - TypeScript interfaces based on API responses
      - Error handling for API calls
      - Loading states
      - Origin UI styling
      - Usage examples with real API integration
    `;
    
    return { enhancedPrompt };
  }
});
```

### **Step 6: Update Chat API Route**

**What to build:** Integrate both tools into chat flow

**Files to modify:**
- `app/api/chat/route.ts` - Add both tools to streamText

**Implementation approach:**
```typescript
import { browseTool } from '@/lib/tools/browseTool';
import { generateTool } from '@/lib/tools/generateTool';

export async function POST(req: Request) {
  const { messages } = await req.json();

  const result = await streamText({
    model: google('gemini-2.5-pro'),
    messages,
    tools: {
      browse_documentation: browseTool,    // New tool
      generate_component: generateTool     // Enhanced tool
    },
    maxSteps: 3, // Allow multi-step execution
    temperature: 0.1,
    system: `You are an expert React developer. When users provide URLs, use the browse_documentation tool first to analyze the APIs, then use generate_component tool to create integrated components.`
  });

  return result.toDataStreamResponse();
}
```

### **Step 7: Add Documentation Summary Display**

**What to build:** Show documentation analysis in chat

**Files to create:**
- `components/chat/DocumentationSummary.tsx` - Display scraped docs summary

**Implementation approach:**
```typescript
// Component to show documentation analysis results
export function DocumentationSummary({ results }) {
  return (
    <Card className="mb-4">
      <CardHeader>
        <CardTitle>üìö Documentation Analysis</CardTitle>
      </CardHeader>
      <CardContent>
        {results.map((result, idx) => (
          <div key={idx} className="mb-4">
            <h4 className="font-medium">{new URL(result.url).hostname}</h4>
            <p className="text-sm text-gray-600">{result.analysis?.summary}</p>
            <div className="flex gap-2 mt-2">
              {result.analysis?.endpoints?.map((endpoint, i) => (
                <Badge key={i} variant="outline">{endpoint}</Badge>
              ))}
            </div>
          </div>
        ))}
      </CardContent>
    </Card>
  );
}
```

### **Step 8: Enhance Instructions Tab**

**What to build:** Better implementation guides with API setup

**Files to modify:**
- `components/preview/InstructionsTab.tsx` - Add API setup instructions

**Implementation approach:**
```typescript
// Enhanced instructions with API-specific setup
const generateAPIInstructions = (documentationResults) => {
  return `
## API Setup

${documentationResults.map(result => `
### ${result.domain}
1. Sign up at ${result.url}
2. Get API key from dashboard
3. Add to environment: \`${result.envVarName}=your_api_key\`
`).join('\n')}

## Component Usage
\`\`\`tsx
<${componentName} 
  apiKey={process.env.${envVarName}}
  onSuccess={(data) => console.log(data)}
  onError={(error) => console.error(error)}
/>
\`\`\`

## Error Handling
- Handle authentication errors (401)
- Implement retry logic for rate limits (429)
- Validate required props before API calls
  `;
};
```

### **Step 9: Test Multi-API Integration**

**What to test:** The billingsdk.com + dodopayments.com example

**Test flow:**
1. User inputs: "Browse https://billingsdk.com/docs and https://dodopayments.com/docs and create a unified pricing component"
2. System should:
   - Detect 2 URLs
   - Scrape both documentation sites
   - Analyze API structures
   - Generate component integrating both APIs
   - Provide setup instructions for both services

**Testing approach:**
```typescript
// Test message for development
const testMessage = `
  Browse https://stripe.com/docs/api and https://docs.developers.paypal.com 
  and create a unified payment component with pricing tiers
`;

// Expected AI workflow:
// 1. browseTool extracts both API documentation
// 2. generateTool creates component using both APIs
// 3. Result shows unified component with both integrations
```

### **Step 10: Production Deployment Considerations**

**What to prepare:**

1. **Environment Variables:**
```bash
FIRECRAWL_API_KEY=your_key
PUPPETEER_EXECUTABLE_PATH=/usr/bin/chromium  # For Vercel
```

2. **Vercel Configuration:**
```json
// vercel.json
{
  "functions": {
    "app/api/scrape/route.ts": { "maxDuration": 30 },
    "app/api/chat/route.ts": { "maxDuration": 30 }
  }
}
```

3. **Error Handling:**
- Timeout handling for slow documentation sites
- Graceful fallback when scraping fails
- User-friendly error messages

**Reference docs:**
- Vercel deployment: https://vercel.com/docs/deployments
- Environment variables: https://nextjs.org/docs/app/building-your-application/configuring/environment-variables

## üéØ **Expected Final Outcome**

**User Experience:**
```
User: "Browse https://stripe.com/docs and create payment form component"

System Response:
1. üåê "Browsing Stripe documentation..."
2. üìä "Found API endpoints: /charges, /customers, /payment-methods..."  
3. ‚ö° "Generating payment component with Stripe integration..."
4. üìã "Component generated with setup instructions"

Result:
- TypeScript component with Stripe API integration
- Props based on Stripe API requirements  
- Step-by-step setup guide
- Error handling for Stripe-specific errors
```

**Success Criteria:**
‚úÖ Detects URLs in user messages
‚úÖ Successfully scrapes documentation content
‚úÖ Generates components with API-specific props
‚úÖ Provides implementation instructions
‚úÖ Handles multiple APIs in single request
‚úÖ Works with billing + payment example scenario

This step-by-step approach will extend your existing Prism app with smart documentation analysis while keeping the implementation clean and minimal.